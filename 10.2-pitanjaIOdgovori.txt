1. ZaÅ¡to je bolje vratiti novi niz iz processCourses, nego mijenjati postojeÄ‡i?
Bolje je vratiti novi niz jer izbjegavamo mutiranje originalnih podataka, Å¡to Äini kod sigurnijim i lakÅ¡im za odrÅ¾avanje.

2. Å to bi se dogodilo da processCourses direktno mijenja objekte iz courses?
Da funkcija processCourses direktno mijenja objekte iz course izgubili bi prvobitnu vrijednost svojstva isActive, 
a svojstvo duration bi bilo potpuno uklonjeno.

isActive bi bio izgubljen jer ga zamjenjujeÅ¡ s status
duration bi nestao jer ga viÅ¡e ne kopiraÅ¡
originalni podaci postaju neupotrebljivi za druge dijelove aplikacije

3. ZaÅ¡to je Array.isArray() bolji od typeof courses === 'object'?

typeof ne moÅ¾e vratiti 'array'
funkcije su 'function', ali:
nizovi, objekti i instance su 'object'

Zato je Array.isArray() jedini pouzdan naÄin

4. TehniÄki (intervju nivo)

â€Kako JavaScript odreÄ‘uje vrijednost this prilikom poziva funkcije 
i zaÅ¡to se ona gubi kada se metoda klase koristi kao callback u setTimeout?â€œ

Pravilo za pamÄ‡enje ğŸ§ 
Ako proslijediÅ¡ metodu kao callback, gubi this
this u JavaScriptu se odreÄ‘uje u trenutku poziva funkcije, ne u trenutku definicije.
Kada metodu klase proslijedimo kao callback (setTimeout), 
ona se poziva kao obiÄna funkcija, pa gubi referencu na instancu. Problem se rjeÅ¡ava pomoÄ‡u bind ili arrow funkcije.
Zato:
bind() - setTimeout(bot.speak.bind(bot), 1000);
arrow wrapper - setTimeout(() => bot.speak(), 1000);
arrow metoda u klasi - 
class Bot {
  greeting = "Hi Mateo";

  speak = () => {
    console.log(this.greeting);
  }
}

Ovdje this nikad ne gubi kontekst, Äak ni u setTimeout.

5. Microtask queue (Promise, await) se izvrÅ¡ava prije macrotask queue-a (setTimeout, setInterval), 
odmah nakon Å¡to se call stack isprazni.

6. ZaÅ¡to await u for petlji nije paralelan, a Promise.all jest?
Zato Å¡to await Äeka da se Promise zavrÅ¡i prije sljedeÄ‡e iteracije,
dok Promise.all pokreÄ‡e sve Promise odjednom i Äeka ih zajedno.

7. Kada bi koristio factory function umjesto class?
Factory function bih koristio kada Å¾elim izbjegnuti this, new i probleme s bindingom, 
te imati veÄ‡u fleksibilnost bez klasa.

8. Je li constructor funkcija isto Å¡to i factory?
NE.

Constructor funkcija:
koristi this
zahtijeva new
radi s prototype-om

Factory funkcija:
vraÄ‡a objekt
ne koristi this
ne koristi new

Factory funkcije koristim kada Å¾elim jednostavne objekte bez this i new, 
dok class koristim kada mi treba struktura, nasljeÄ‘ivanje i dijeljene metode preko prototype-a.